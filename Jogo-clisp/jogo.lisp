(defun shuffle (string)
  	(let ((length (length string))
        (result (copy-seq string)))
    	(dotimes (i length result)
      		(dotimes (j length)
        		(when (and (/= i j)
                   	(char/= (aref string i) (aref result j))
                	   (char/= (aref string j) (aref result i)))
          		(rotatef (aref result i) (aref result j)))
      		)
    	)
   	)
)
(defun finde (palavra arquivo)
	(defvar tam (length arquivo))
	(loop for s from 0 to (- tam 1) do
		(if (string= palavra (nth s arquivo))
			(return-from finde t)
		)
	)
	(return-from finde nil)
)
(defun printPontos (palavrasAbertas arquivo)
	(defvar tam (length arquivo))
	(loop for fs from 0 to (- tam 1) do
		(if (finde (nth fs  arquivo) palavrasAbertas)
			((lambda (x)
				(format t "~a~%" x)
			)(nth fs arquivo))
			((lambda (x) 
				(loop for k from 0 to (- x 1) do
					(format t "-")
				)
				(format t "~%")
			)(length (nth fs  arquivo)))
		)
	)
)
(defun printar (level arquivo tentativa)
	(setq palavrasAbertas nil)
	(defvar palavra nil)
	(loop for s from 0 to tentativa do
		(if (string= "sair" palavra)  (return-from printar "q"))
		(format t "~C[2J" #\Esc)
		(format t "----------------------------------------------------------------------------------------- ~%")
		(format t "Level:~a~%" level)
		(format t "Tentativas: ~a~%" (- tentativa s))
		(format t "Digite 'sair' para sair quando quiser ~%")
		(format t "Digite 'proximo' para avanÃ§ar caso tenha acertado mais que 5 palavras")
		(format t "~%~%~%~%~%~%~%")
		(if (finde palavra arquivo) 
			(if (finde palavra palavrasAbertas) 
				nil 
				(push palavra palavrasAbertas)
			)
		)
		(if (= (length palavrasAbertas) (length arquivo)) 
				((lambda () 
					(format t "Parabens Voce Conseguiu!") (sleep 4) (return-from printar t))
				)
		)
		(printPontos palavrasAbertas arquivo)
		(format t "Letras:~a~%"(shuffle (first arquivo)))
		(format t "Digite uma Palavra:")
		(setq palavra (string-downcase (read)))
		(if (string= palavra "proximo") 
			(if (>= (length palavrasAbertas) 5) 
				(return-from printar t) 
				((lambda () (format t "VOCE NAO ATINGIU O MINIMO, TENTE MAIS!") (sleep 4)))
			)
		)
		(format t "----------------------------------------------------------------------------------------- ~%")

	)
	(if (>= (length palavrasAbertas) 5) 
			(return-from printar t) 
			((lambda () (format t "VOCE NAO ATINGIU O MINIMO, TENTE MAIS!") (sleep 4)))
	)
	(format t "Voce Perdeu!!! Digite 'sair' para desistir ou 'novamente' para tentar mais uma vez!~%")
	(return-from printar (string-downcase (read)))
)
(defun princial ()
	(defvar palavras nil)
	(defvar cont 0)
	(defvar boleano t)
	(loop while boleano do
			(incf cont)
			(if (> cont 5) (return-from princial 0))

			(let ((in (open (concatenate 'string (princ-to-string cont) ".txt") :if-does-not-exist nil)))
				(setq palavras nil)
  				(when in
    				(loop for line = (read-line in nil)
         				while line do (push line palavras)
					)
    				(close in)
				)
			)
    	(setq resultado (printar cont palavras 15 ))
    			(if (string= resultado "sair") 
    				(return-from princial 0)
    				(if (string= resultado "q")
    					(return-from princial 0)
    					(if (string= resultado "novamente") 
    						(decf cont)
    						(if (string= resultado t) 
    							nil
    							(if (string= resultado "proximo")
    								nil
    								(decf cont )
    							)
    						)
    					)
    				)
    			)
	)
)
(princial)